# -*- coding: utf-8 -*-
"""OpenBMP forwarder

  Copyright (c) 2013-2015 Cisco Systems, Inc. and others.  All rights reserved.
  This program and the accompanying materials are made available under the
  terms of the Eclipse Public License v1.0 which accompanies this distribution,
  and is available at http://www.eclipse.org/legal/epl-v10.html

  .. moduleauthor:: Tim Evens <tievens@cisco.com>
"""
import multiprocessing
import socket
import kafka
import kafka.common
import copy
import time
import re


from openbmp.logger import init_mp_logger
from openbmp.parsed.headers import headers as parsed_headers
from openbmp.parsed.collector import collector
from openbmp.parsed.router import router


class BMPMessageObject(object):
    """ OpenBMP consumer message object which is used between internal queues """
    #: BMP Message
    BMP_MSG = None

    #: Collector Admin ID
    COLLECTOR_ADMIN_ID = ""

    #: Router IP
    ROUTER_IP = ""

    #: Router Name
    ROUTER_NAME = ""


class BMPConsumer(multiprocessing.Process):
    """ OpenBMP consumer for forwarding

        Consumes openbmp.parsed.collector, openbmp.parsed.router, and openbmp.bmp_raw
        message feeds from Kafka.  Collector and router messages are cached so the data can
        be used when forwarding. BMP messages
    """
    # Memory cache of collectors
    COLLECTORS = {}

    # Memory cache of routers
    ROUTERS = {}

    def __init__(self, cfg, forward_queue, log_queue):
        """ Constructor

            :param cfg:             Configuration dictionary
            :param forward_queue:   Output for BMP raw message forwarding
            :param log_queue:       Logging queue - sync logging
        """
        multiprocessing.Process.__init__(self)
        self._stop = multiprocessing.Event()

        self._cfg = cfg
        self._fwd_queue = forward_queue
        self._log_queue = log_queue
        self.LOG = None

    def run(self):
        """ Override """
        self.LOG = init_mp_logger("bmp_consumer", self._log_queue)

        # Enable to topics/feeds
        topics = ['openbmp.parsed.collector', 'openbmp.parsed.router', 'openbmp.bmp_raw']

        self.LOG.info("Running bmp_consumer")

        # wait for config to load
        while not self.stopped():
            if self._cfg and 'kafka' in self._cfg:
                break


        try:
            # connect and bind to topics
            self.LOG.info("Connecting to %s ... takes a minute to load offsets and topics, please wait" % self._cfg['kafka']['servers'])
            consumer = kafka.KafkaConsumer(*topics,
                                           bootstrap_servers=self._cfg['kafka']['servers'],
                                           client_id=self._cfg['kafka']['client_id'] + '-' + socket.gethostname(),
                                           group_id=self._cfg['kafka']['group_id'],
                                           enable_auto_commit=True,
                                           auto_commit_interval_ms=1000,
                                           auto_offset_reset='latest' if self._cfg['kafka']['offset_reset_largest'] else "smallest")

            self.LOG.info("Connected, now consuming")

            prev_ts = time.time()

            # Loop till stopped
            while not self.stopped():

                # Read messages
                for m in consumer:
                    if self.stopped():
                        break

                    self.process_msg(m)

        except kafka.common.KafkaUnavailableError as err:
            self.LOG.error("Kafka Error: %s" % str(err))

        except KeyboardInterrupt:
            pass

        self.LOG.info("consumer stopped")

    def stop(self):
        self._stop.set()

    def stopped(self):
        return self._stop.is_set()

    def process_msg(self, msg):
        """ Process the message

        :param msg:     Message consumed
        """
        (headers, data) = msg.value.split("\n\n", 1)

        hdr = parsed_headers()
        hdr.parse(headers)

        if msg.topic == 'openbmp.parsed.collector':
            self.process_collector_msg(hdr.getCollectorHashId(), data)

        if msg.topic == 'openbmp.parsed.router':
            self.process_router_msg(hdr.getCollectorHashId(), data)

        elif msg.topic == 'openbmp.bmp_raw':
            self.process_bmp_raw_msg(hdr.getCollectorHashId(),
                                     hdr.getRouterHashId(), hdr.getRouterIp(), data)

    def process_collector_msg(self, c_hash, data):
        """ Process collector message and cache info for use later

            :param c_hash:      Collector Hash ID
            :param data:        Message data to be consumed (should not contain headers)
        """
        obj = collector()

        for row in data.split('\n'):
            if len(row):
                try:
                    obj.parse(row)

                    self.LOG.debug("collector: %s [%s]", obj.getAdminId(), obj.getAction())

                    if obj.getAction() in ('started', 'heartbeat', 'change'):

                        # Update collector hash/cache
                        if obj.getHashId() not in self.COLLECTORS:
                            self.COLLECTORS[obj.getHashId()] = {'admin_id': obj.getAdminId()}

                    else:
                        self.COLLECTORS.pop(obj.getHashId(), None)

                except:
                    pass

    def process_router_msg(self, c_hash, data):
        """ Process Router message

            :param c_hash:      Collector Hash ID
            :param data:        Message data to be consumed (should not contain headers)
        """
        obj = router()

        # Log messages
        for row in data.split('\n'):
            if len(row):
                try:
                    obj.parse(row)

                    self.LOG.debug("router: [%s] %s %s", obj.getAction(),
                                   obj.getName(), obj.getIpAddress())

                    if obj.getAction() in ('first', 'init'):
                        # Update the router hash/cache
                        if obj.getHashId() not in self.ROUTERS:
                            self.ROUTERS[obj.getHashId()] = {'ip': obj.getIpAddress(),
                                                              'name': obj.getName()}
                    # else:
                    #     self.ROUTERS.pop(obj.getHashId(), None)

                except:
                    self.LOG.debug("router parse error");
                    pass

    def process_bmp_raw_msg(self, c_hash, r_hash, r_ip, data):
        """ Process BMP RAW message

        :param c_hash:      Collector Hash ID
        :param r_hash:      Router Hash ID
        :param r_ip:        Router IP address
        :param data:        Message data to be consumed (should not contain headers)
        """
        msg = BMPMessageObject()

        try:
            msg.COLLECTOR_ADMIN_ID = self.COLLECTORS['admin_id']
            msg.ROUTER_IP = self.ROUTERS['ip']
            msg.ROUTER_NAME = self.ROUTERS['name']

        except:
            pass

        msg.BMP_MSG = data
        self._fwd_queue.put(msg)
