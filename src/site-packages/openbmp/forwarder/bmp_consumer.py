# -*- coding: utf-8 -*-
"""OpenBMP forwarder

  Copyright (c) 2013-2015 Cisco Systems, Inc. and others.  All rights reserved.
  This program and the accompanying materials are made available under the
  terms of the Eclipse Public License v1.0 which accompanies this distribution,
  and is available at http://www.eclipse.org/legal/epl-v10.html

  .. moduleauthor:: Tim Evens <tievens@cisco.com>
"""
import multiprocessing
import socket
import kafka
import kafka.common
import copy
import time
import re
import sys

from openbmp.forwarder.logger import init_mp_logger

from openbmp.api.parsed.message import Message
from openbmp.api.parsed.message import Router
from openbmp.api.parsed.message import Collector
from openbmp.api.parsed.message import MsgBusFields

class BMPMessageObject(object):
    """ OpenBMP consumer message object which is used between internal queues """
    #: BMP Message
    BMP_MSG = None

    #: Collector Admin ID
    COLLECTOR_ADMIN_ID = ""

    #: Router IP
    ROUTER_IP = ""

    #: Router Name
    ROUTER_NAME = ""


class BMPConsumer(multiprocessing.Process):
    """ OpenBMP consumer for forwarding

        Consumes openbmp.parsed.collector, openbmp.parsed.router, and openbmp.bmp_raw
        message feeds from Kafka.  Collector and router messages are cached so the data can
        be used when forwarding. BMP messages
    """
    # Memory cache of collectors
    COLLECTORS = {}

    # Memory cache of routers
    ROUTERS = {}

    def __init__(self, cfg, forward_queue, log_queue):
        """ Constructor

            :param cfg:             Configuration dictionary
            :param forward_queue:   Output for BMP raw message forwarding
            :param log_queue:       Logging queue - sync logging
        """
        multiprocessing.Process.__init__(self)
        self._stop = multiprocessing.Event()

        self._cfg = cfg
        self._fwd_queue = forward_queue
        self._log_queue = log_queue
        self.LOG = None

    def run(self):
        """ Override """
        self.LOG = init_mp_logger("bmp_consumer", self._log_queue)

        # Enable to topics/feeds
        topics = ['openbmp.parsed.collector', 'openbmp.parsed.router', 'openbmp.bmp_raw']

        self.LOG.info("Running bmp_consumer")

        # wait for config to load
        while not self.stopped():
            if self._cfg and 'kafka' in self._cfg:
                break


        try:
            # connect and bind to topics
            self.LOG.info("Connecting to %s ... takes a minute to load offsets and topics, please wait" % self._cfg['kafka']['servers'])
            consumer = kafka.KafkaConsumer(*topics,
                                           bootstrap_servers=self._cfg['kafka']['servers'],
                                           client_id=self._cfg['kafka']['client_id'] + '-' + socket.gethostname(),
                                           group_id=self._cfg['kafka']['group_id'],
                                           enable_auto_commit=True,
                                           auto_commit_interval_ms=1000,
                                           auto_offset_reset='latest' if self._cfg['kafka']['offset_reset_largest'] else "smallest")

            self.LOG.info("Connected, now consuming")

            prev_ts = time.time()

            # Loop till stopped
            while not self.stopped():

                # Read messages
                for m in consumer:
                    if self.stopped():
                        break

                    self.process_msg(m)

        except kafka.common.KafkaUnavailableError as err:
            self.LOG.error("Kafka Error: %s" % str(err))

        except KeyboardInterrupt:
            pass

        self.LOG.info("consumer stopped")

    def stop(self):
        self._stop.set()

    def stopped(self):
        return self._stop.is_set()

    def process_msg(self, msg):
        """ Process the message

        :param msg:     Message consumed
        """

        print msg

        m = Message(msg.value)  # Gets body of kafka message and creates Message object.

        if msg.topic == 'openbmp.parsed.collector':
            self.process_collector_msg(m)

        if msg.topic == 'openbmp.parsed.router':
            self.process_router_msg(m)

        elif msg.topic == 'openbmp.bmp_raw':
            self.process_bmp_raw_msg(m)

    def process_collector_msg(self, m):
        """ Process collector message and cache info for use later

            :param m:   Message object.
        """
        c = Collector(m)
        map_list = c.get_row_map()

        for row in map_list:
            if len(row):
                try:
                    self.LOG.debug("collector: %s [%s]", row[MsgBusFields.ADMIN_ID.getName()], row[MsgBusFields.ACTION.getName()])

                    if row[MsgBusFields.ACTION.getName()] in ('started', 'heartbeat', 'change'):

                        # Update collector hash/cache
                        if row[MsgBusFields.HASH.getName()] not in self.COLLECTORS:
                            self.COLLECTORS[row[MsgBusFields.HASH.getName()]] = {'admin_id': row[MsgBusFields.ADMIN_ID.getName()]}

                    else:
                        self.COLLECTORS.pop(row[MsgBusFields.HASH.getName()], None)

                except:
                    pass

    def process_router_msg(self, m):
        """ Process Router message

           :param m:   Message object.
        """
        r = Router(m)
        map_list = r.get_row_map()

        # Log messages
        for row in map_list:
            if len(row):
                try:
                    self.LOG.debug("router: [%s] %s %s", row[MsgBusFields.ACTION.getName()],
                                   row[MsgBusFields.NAME.getName()], row[MsgBusFields.IP_ADDRESS.getName()])

                    if row[MsgBusFields.ACTION.getName()] in ('first', 'init'):
                        # Update the router hash/cache
                        if row[MsgBusFields.HASH.getName()] not in self.ROUTERS:
                            self.ROUTERS[row[MsgBusFields.HASH.getName()]] = {'ip': row[MsgBusFields.IP_ADDRESS.getName()],
                                                              'name': row[MsgBusFields.NAME.getName()]}
                    # else:
                    #     self.ROUTERS.pop(row[MsgBusFields.HASH.getName()], None)

                except:
                    self.LOG.debug("router parse error");
                    pass

    def process_bmp_raw_msg(self, m):
        """ Process BMP RAW message

            :param m:   Message object.
        """
        bmp_msg_obj = BMPMessageObject()

        try:
            bmp_msg_obj.COLLECTOR_ADMIN_ID = self.COLLECTORS[m.getCollector_hash_id()] #collector hash
            bmp_msg_obj.ROUTER_IP = self.ROUTERS[m.getRouter_hash_id()]['ip'] #router ip
            bmp_msg_obj.ROUTER_NAME = self.ROUTERS[m.getRouter_hash_id()]['name'] #router name

        except:
            pass

        bmp_msg_obj.BMP_MSG = m.get_content()

        print bmp_msg_obj.COLLECTOR_ADMIN_ID

        self._fwd_queue.put(bmp_msg_obj)
